# Regras Globais do Projeto Assusa

## ğŸ“ PadrÃ£o de Commits (CRÃTICO)

**NUNCA acumule commits grandes. Sempre divida em fases e partes.**

- Cada commit deve representar uma **funcionalidade especÃ­fica** e ser **compreensÃ­vel por si sÃ³**
- Commits devem ser **pequenos e focados** para facilitar manutenÃ§Ã£o e revisÃ£o
- Respeite o padrÃ£o **Conventional Commits** jÃ¡ existente no projeto:
  - Formato: `tipo(escopo?): descriÃ§Ã£o em portuguÃªs`
  - Tipos: `feat`, `test`, `docs`, `chore`, `fix`, `refactor`
  - Escopo Ã© **opcional** e deve refletir a camada/mÃ³dulo afetado:
    - `adapters` - para adapters (whatsapp, sicoob, google, redis, http)
    - `domain` - para entidades, ports, use cases, value objects
    - `application` - para serviÃ§os de aplicaÃ§Ã£o
    - `infra` - para infrastructure (config, logging, security)
    - `docker` - para Dockerfile e configuraÃ§Ãµes de container
  - DescriÃ§Ã£o deve ser **especÃ­fica e clara** sobre o que foi implementado/alterado

### Exemplos de Commits VÃ¡lidos (baseados no histÃ³rico do projeto):
- âœ… `feat(adapters): implementa adapter WhatsApp Cloud API`
- âœ… `feat(adapters): implementa RateLimiter com Redis`
- âœ… `feat(domain): implementa use case GerarSegundaVia`
- âœ… `test: adiciona testes para CPF Handler`
- âœ… `docs: adiciona documentaÃ§Ã£o completa do projeto`
- âœ… `chore: remove arquivos .gitkeep desnecessÃ¡rios`

### Exemplos de Commits INVÃLIDOS:
- âŒ `feat: implementa sistema completo` (muito genÃ©rico, vÃ¡rias funcionalidades)
- âŒ `fix: corrige bugs e adiciona features` (mÃºltiplas mudanÃ§as)
- âŒ `chore: atualiza cÃ³digo` (pouco descritivo)

**Regra de Ouro**: Se vocÃª precisar usar "e" ou "tambÃ©m" na mensagem do commit, provavelmente precisa dividir em mÃºltiplos commits.

## ğŸŒ Idioma e ComunicaÃ§Ã£o

- Sempre responder em **portuguÃªs**
- DocumentaÃ§Ã£o e comentÃ¡rios em cÃ³digo devem estar em **portuguÃªs**
- Mensagens de commit em **portuguÃªs**

## ğŸ—ï¸ Arquitetura

O projeto segue **Clean Architecture (Ports & Adapters)**. Respeite a separaÃ§Ã£o de camadas:

- **Domain** (`src/domain/`): Regras de negÃ³cio puras, sem dependÃªncias externas
  - Entities: Entidades de domÃ­nio
  - Use Cases: Casos de uso
  - Value Objects: Objetos de valor
  - **Apenas ports puramente de domÃ­nio** (genÃ©ricos e abstratos, raros)

- **Application** (`src/application/`): ServiÃ§os que orquestram casos de uso
  - Services: ServiÃ§os de aplicaÃ§Ã£o
  - **Ports de integraÃ§Ãµes externas** (`src/application/ports/driven/`): Interfaces de integraÃ§Ãµes externas
    - WhatsApp, Sicoob, Google Drive, Google Sheets, Redis, HTTP, etc.
  - **Ports de entrada** (`src/application/ports/driving/`): Interfaces de controllers/handlers (se existirem)

- **Adapters** (`src/adapters/`): ImplementaÃ§Ãµes concretas das portas
  - http: Servidor Fastify
  - whatsapp: Adapter WhatsApp Cloud API
  - sicoob: Adapter Sicoob API
  - google: Adapters Google Drive/Sheets
  - redis: Adapter Redis (com fallback em memÃ³ria)
  - in-memory: ImplementaÃ§Ãµes em memÃ³ria para desenvolvimento/testes

- **Infrastructure** (`src/infrastructure/`): ConfiguraÃ§Ã£o, logging, seguranÃ§a

### ğŸ“ Regra Arquitetural: LocalizaÃ§Ã£o de Ports

**CRÃTICO**: Ports de integraÃ§Ãµes externas **NUNCA** devem ficar em `src/domain/ports/`.

- âœ… **Ports de integraÃ§Ãµes externas** â†’ `src/application/ports/driven/`
  - Exemplos: `WhatsAppPort`, `SicoobPort`, `DrivePort`, `SheetsPort`, `StoragePort`, `RateLimiter`, `Logger`, etc.
  - **CritÃ©rio**: Se o nome do port "parece integraÃ§Ã£o", ele NÃƒO Ã© domÃ­nio.

- âœ… **Ports puramente de domÃ­nio** (raros) â†’ `src/domain/ports/`
  - Exemplos: `Clock`, `IdGenerator`, `Hasher`, `RandomProvider`, abstraÃ§Ãµes de polÃ­ticas de domÃ­nio
  - **CritÃ©rio**: GenÃ©ricos, abstratos, nÃ£o sÃ£o integraÃ§Ãµes especÃ­ficas.

**MigraÃ§Ã£o gradual**: Ports legados em `src/domain/ports/` possuem arquivos ponte (reexports) durante a migraÃ§Ã£o incremental.

**ReferÃªncia**: Ver ADR-0001 em `docs/adr/ADR-0001-ports-na-application.md`

## ğŸ’» PadrÃµes de CÃ³digo TypeScript

- Use **TypeScript** com tipos explÃ­citos (evitar `any`)
- Nomes de variÃ¡veis e funÃ§Ãµes em **camelCase**
- Nomes de classes e interfaces em **PascalCase**
- Use **async/await** ao invÃ©s de `Promise.then()`
- Sempre tratar erros adequadamente com **try/catch**
- Use **interfaces** para definir contratos (Ports)
- Prefira **injeÃ§Ã£o de dependÃªncias** via construtor

## ğŸ”’ LGPD e SeguranÃ§a

- **CPFs sempre devem ser hasheados** antes de armazenar (usar `CpfHandler.hashCpf()`)
- **CPFs nunca devem aparecer em logs** - sempre usar mascaramento (`CpfHandler.maskCpf()`)
- Validar todos os inputs do usuÃ¡rio
- Nunca commitar dados sensÃ­veis ou secrets
- Usar variÃ¡veis de ambiente para configuraÃ§Ãµes sensÃ­veis

## ğŸ§ª Testes

- Adicionar **testes unitÃ¡rios** para novas funcionalidades
- Testes devem ser isolados e independentes
- Usar mocks para dependÃªncias externas
- Manter cobertura de testes adequada
- Testes em portuguÃªs (describe/it em portuguÃªs)

## ğŸ“¦ Estrutura de Arquivos

- Um arquivo por classe/funÃ§Ã£o principal
- Agrupar arquivos relacionados em diretÃ³rios
- Usar exports nomeados ao invÃ©s de default exports
- Seguir a estrutura de pastas jÃ¡ estabelecida

## ğŸ”§ Desenvolvimento

- Usar `npm run dev` para desenvolvimento com hot-reload
- Executar `npm test` antes de commitar
- Verificar lint com `npm run lint`
- Type-check com `npm run type-check`

## ğŸ“š DocumentaÃ§Ã£o

- Atualizar README.md quando adicionar funcionalidades significativas
- Documentar funÃ§Ãµes complexas com JSDoc
- Manter comentÃ¡rios explicativos apenas quando necessÃ¡rio (cÃ³digo deve ser auto-explicativo)
